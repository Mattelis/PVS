(inf_prime_topology
 (union_open_is_open 0
  (union_open_is_open-1 nil 3894301462
   ("" (skeep)
    (("" (typepred "O" "S")
      (("" (expand "open_N_Z?" (-1 -2))
        (("" (prop)
          (("1" (grind) nil nil)
           ("2" (replaces -2)
            (("2" (rewrite "union_commutative[int]")
              (("2" (rewrite "union_empty[int]")
                (("2" (typepred "S") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (replaces -1)
            (("3" (rewrite "union_empty[int]")
              (("3" (typepred "o") (("3" (propax) nil nil)) nil)) nil))
            nil)
           ("4" (expand "open_N_Z?")
            (("4" (flatten)
              (("4" (hide 1)
                (("4" (skeep)
                  (("4" (typepred "a")
                    (("4" (expand "union" -1)
                      (("4" (split)
                        (("1" (hide -2)
                          (("1" (inst?)
                            (("1" (skeep)
                              (("1"
                                (hide -1)
                                (("1"
                                  (inst 1 "b")
                                  (("1"
                                    (lemma "union_subset1[int]")
                                    (("1"
                                      (inst -1 "O" "S")
                                      (("1"
                                        (lemma
                                         "subset_transitive[int]")
                                        (("1"
                                          (inst
                                           -1
                                           "N(a)(b)"
                                           "O"
                                           "union(O,S)")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (hide -3)
                          (("2" (inst?)
                            (("1" (skeep)
                              (("1"
                                (inst?)
                                (("1"
                                  (hide -1)
                                  (("1"
                                    (rewrite "union_commutative")
                                    (("1"
                                      (lemma "union_subset1[int]")
                                      (("1"
                                        (inst -1 "S" "O")
                                        (("1"
                                          (lemma
                                           "subset_transitive[int]")
                                          (("1"
                                            (inst
                                             -1
                                             "N(a)(b)"
                                             "S"
                                             "union(S,O)")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((open_N_Z? const-decl "bool" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (emptyset const-decl "set" sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (union_commutative formula-decl nil sets_lemmas nil)
    (union_empty formula-decl nil sets_lemmas nil)
    (TRUE const-decl "bool" booleans nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset_transitive formula-decl nil sets_lemmas nil)
    (union_subset1 formula-decl nil sets_lemmas nil))
   SHOSTAK))
 (any_union_open_is_open 0
  (any_union_open_is_open-1 nil 3894301551
   ("" (skeep)
    (("" (expand "open_N_Z?")
      (("" (prop)
        (("" (skeep)
          (("" (typepred "a")
            (("" (expand "Union" -1)
              (("" (skeep)
                (("" (typepred "a_1")
                  (("" (inst -3 "a_1")
                    (("" (prop)
                      (("1" (decompose-equality)
                        (("1" (inst -1 "a")
                          (("1" (iff)
                            (("1" (prop)
                              (("1"
                                (expand "emptyset")
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst -1 "a")
                        (("2" (skosimp)
                          (("2" (inst 2 "b!1")
                            (("2" (lemma "Union_subset[int]")
                              (("2"
                                (inst -1 "A" "a_1")
                                (("2"
                                  (lemma "subset_transitive[int]")
                                  (("2"
                                    (inst
                                     -1
                                     "N(a)(b!1)"
                                     "a_1"
                                     "Union(A)")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((open_N_Z? const-decl "bool" inf_prime_topology nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (emptyset const-decl "set" sets nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (Union_subset formula-decl nil sets_lemmas nil)
    (subset_transitive formula-decl nil sets_lemmas nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (Union const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   SHOSTAK))
 (inter_open_is_open 0
  (inter_open_is_open-1 nil 3894301552
   ("" (skeep)
    (("" (expand "open_N_Z?")
      (("" (typepred "o" "S")
        (("" (expand "open_N_Z?")
          (("" (prop)
            (("1" (grind) nil nil)
             ("2" (replaces -2)
              (("2" (rewrite "intersection_commutative[int]")
                (("2" (rewrite "intersection_empty[int]") nil nil))
                nil))
              nil)
             ("3" (replaces -1)
              (("3" (rewrite "intersection_empty[int]") nil nil)) nil)
             ("4" (hide 1)
              (("4" (skosimp)
                (("4" (typepred "a!1")
                  (("4" (expand "intersection" -1)
                    (("4" (prop)
                      (("4" (inst -3 "a!1")
                        (("1" (inst -4 "a!1")
                          (("1" (skosimp)
                            (("1" (skosimp)
                              (("1"
                                (inst 1 "b!1*b!2")
                                (("1"
                                  (lemma
                                   "intersection_lower_bound[int]")
                                  (("1"
                                    (inst
                                     -1
                                     "S"
                                     "o"
                                     "N(a!1)(b!1 * b!2)")
                                    (("1"
                                      (prop)
                                      (("1"
                                        (lemma
                                         "intersection_commutative[int]")
                                        (("1"
                                          (inst -1 "S" "o")
                                          (("1"
                                            (replace -1 -2)
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide -4 2)
                                        (("2"
                                          (expand "subset?")
                                          (("2"
                                            (skosimp)
                                            (("2"
                                              (expand "member")
                                              (("2"
                                                (expand "N")
                                                (("2"
                                                  (skosimp)
                                                  (("2"
                                                    (inst -4 "x!1")
                                                    (("2"
                                                      (prop)
                                                      (("2"
                                                        (inst
                                                         1
                                                         "n!1*b!2")
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (hide -3 2)
                                        (("3"
                                          (expand "subset?")
                                          (("3"
                                            (skosimp)
                                            (("3"
                                              (expand "member")
                                              (("3"
                                                (expand "N")
                                                (("3"
                                                  (skosimp)
                                                  (("3"
                                                    (inst -4 "x!1")
                                                    (("3"
                                                      (prop)
                                                      (("3"
                                                        (inst
                                                         1
                                                         "n!1*b!1")
                                                        (("3"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "member")
                            (("2" (propax) nil nil)) nil))
                          nil)
                         ("2" (expand "member")
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((open_N_Z? const-decl "bool" inf_prime_topology nil)
    (intersection_lower_bound formula-decl nil sets_lemmas nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (TRUE const-decl "bool" booleans nil)
    (intersection_empty formula-decl nil sets_lemmas nil)
    (intersection_commutative formula-decl nil sets_lemmas nil)
    (finite_intersection1 application-judgement "finite_set"
     finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (subset? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   SHOSTAK))
 (fin_inter_open_is_open 0
  (fin_inter_open_is_open-1 nil 3894301553
   ("" (measure-induct+ "card(W)" "W")
    (("" (case-replace "x!1 =emptyset[set[int]]")
      (("1" (lemma "Intersection_empty_full[int]")
        (("1" (lemma "fullset_is_full?[int]")
          (("1" (inst -1 "Intersection(emptyset[set[int]])")
            (("1" (assert)
              (("1" (replace -1 1)
                (("1" (expand "open_N_Z?")
                  (("1" (flatten)
                    (("1" (skeep)
                      (("1" (inst 2 "1")
                        (("1" (expand "subset?")
                          (("1" (skeep)
                            (("1" (hide-all-but (-6 2))
                              (("1"
                                (expand "member")
                                (("1"
                                  (expand "N")
                                  (("1"
                                    (expand "fullset")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "card(x!1) = 1")
        (("1" (hide -2)
          (("1" (lemma "card_one[set[int]]")
            (("1" (inst -1 "x!1")
              (("1" (assert)
                (("1" (skeep)
                  (("1" (replace -1 2)
                    (("1" (case-replace "Intersection(singleton(x))=x")
                      (("1" (inst -4 "x")
                        (("1" (hide-all-but (-2 1))
                          (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (decompose-equality)
                          (("2" (iff)
                            (("2" (prop)
                              (("1"
                                (expand "Intersection")
                                (("1"
                                  (inst -1 "x")
                                  (("1"
                                    (expand "singleton")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "Intersection")
                                (("2"
                                  (skeep)
                                  (("2"
                                    (typepred "a")
                                    (("2"
                                      (expand "singleton")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (lemma "Intersection_intersection_rew[int]")
          (("2" (inst -1 "x!1")
            (("2" (assert)
              (("2" (case "nonempty?(x!1)")
                (("1" (assert)
                  (("1" (lemma "card_strict_subset[set[int]]")
                    (("1" (inst -1 "rest(x!1)" "x!1")
                      (("1" (expand "strict_subset?")
                        (("1" (lemma "rest_not_equal[set[int]]")
                          (("1" (lemma "rest_subset[set[int]]")
                            (("1" (inst -6 "rest(x!1)")
                              (("1"
                                (inst -1 "x!1")
                                (("1"
                                  (inst -2 "x!1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (split)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split)
                                          (("1"
                                            (lemma
                                             "inter_open_is_open")
                                            (("1"
                                              (inst
                                               -1
                                               "choose(x!1)"
                                               "Intersection(rest(x!1))")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (hide-all-but
                                                 (-5 -7 1))
                                                (("2"
                                                  (inst
                                                   -2
                                                   "choose[set[int]](x!1)")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide-all-but
                                             (-2 -4 -6 1 2))
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (typepred "o")
                                                (("2"
                                                  (inst -4 "o")
                                                  (("2"
                                                    (expand "subset?")
                                                    (("2"
                                                      (inst -2 "o")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but (-1 2))
                                        (("2"
                                          (decompose-equality)
                                          (("2"
                                            (iff)
                                            (("2"
                                              (prop)
                                              (("1"
                                                (expand "empty?")
                                                (("1"
                                                  (inst -2 "x!2")
                                                  (("1"
                                                    (expand "member")
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand "emptyset")
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but (1 3))
                  (("2" (expand "nonempty?")
                    (("2" (expand "empty?")
                      (("2" (decompose-equality)
                        (("2" (iff)
                          (("2" (prop)
                            (("1" (inst -2 "x!2") nil nil)
                             ("2" (expand "emptyset")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emptyset const-decl "set" sets nil)
    (fullset_is_full? formula-decl nil sets_lemmas nil)
    (Intersection_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (subset? const-decl "bool" sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (Intersection_empty_full formula-decl nil sets_lemmas nil)
    (Intersection_intersection_rew formula-decl nil sets_lemmas nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (rest const-decl "set" sets nil)
    (rest_not_equal formula-decl nil sets_lemmas nil)
    (choose const-decl "(p)" sets nil)
    (inter_open_is_open formula-decl nil inf_prime_topology nil)
    (empty? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rest_subset formula-decl nil sets_lemmas nil)
    (strict_subset? const-decl "bool" sets nil)
    (card_strict_subset formula-decl nil finite_sets nil)
    (nonempty? const-decl "bool" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (card_one formula-decl nil finite_sets nil)
    (Intersection const-decl "set" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   SHOSTAK))
 (int_is_open 0
  (int_is_open-1 nil 3894301554
   ("" (expand "open_N_Z?")
    (("" (flatten)
      (("" (hide 1)
        (("" (skeep)
          (("" (expand N)
            (("" (inst 1 "1")
              (("" (typepred a)
                (("" (assert) (("" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil))
   SHOSTAK))
 (N_Z_topology 0
  (N_Z_topology-1 nil 3894301556
   ("" (expand "topology?")
    (("" (split)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (expand "topology_Union?")
        (("3" (skeep)
          (("3" (lemma "any_union_open_is_open")
            (("3" (inst -1 "U")
              (("3" (split)
                (("1" (hide -2) (("1" (grind) nil nil)) nil)
                 ("2" (skeep)
                  (("2" (expand "subset?")
                    (("2" (typepred "o")
                      (("2" (inst -2 "o") (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (expand "topology_intersection?")
        (("4" (skeep)
          (("4" (typepred "A" "B")
            (("4" (lemma "inter_open_is_open")
              (("4" (inst -1 "A" "B")
                (("1" (hide -2 -3) (("1" (grind) nil nil)) nil)
                 ("2" (hide 2 -1) (("2" (grind) nil nil)) nil)
                 ("3" (hide -2 2) (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (topology_empty? const-decl "bool" topology_prelim topology)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (member const-decl "bool" sets nil)
    (extend const-decl "R" extend nil)
    (fullset const-decl "set" sets nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (topology_full? const-decl "bool" topology_prelim topology)
    (subset? const-decl "bool" sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Union const-decl "set" sets nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (any_union_open_is_open formula-decl nil inf_prime_topology nil)
    (topology_Union? const-decl "bool" topology_prelim topology)
    (inter_open_is_open formula-decl nil inf_prime_topology nil)
    (intersection const-decl "set" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (set type-eq-decl nil sets nil)
    (topology_intersection? const-decl "bool" topology_prelim topology)
    (topology? const-decl "bool" topology_prelim topology))
   SHOSTAK))
 (Nab_is_infinite 0
  (Nab_is_infinite-1 nil 3894301557
   ("" (skeep)
    (("" (expand "is_finite")
      (("" (skeep)
        ((""
          (lemma
           "composition_injective[below[N_1+1],(N(a)(b)),below[N_1]]")
          (("" (inst -1 "LAMBDA(i:below[1+N_1]):a+i*b" "f")
            (("1" (lemma "injection_n_to_m")
              (("1" (inst -1 "N_1" "1+N_1") (("1" (grind) nil nil))
                nil))
              nil)
             ("2" (hide -1)
              (("2" (expand "injective?")
                (("2" (skosimp)
                  (("2" (typepred "b") (("2" (div-by -2 "b") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (composition_injective judgement-tcc nil function_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (/= const-decl "boolean" notequal nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div_cancel2 formula-decl nil extra_real_props nil)
    (both_sides_div1 formula-decl nil real_props nil)
    (injection_n_to_m formula-decl nil nat_fun_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (O const-decl "T3" function_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (injective? const-decl "bool" functions nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   SHOSTAK))
 (Nab_charac 0
  (Nab_charac-1 nil 3894301558
   ("" (skeep)
    (("" (decompose-equality)
      (("" (iff)
        (("" (prop)
          (("1" (expand "complement")
            (("1" (expand "member")
              (("1" (expand "Union")
                (("1" (skosimp)
                  (("1" (typepred "a!1")
                    (("1" (expand "Ni")
                      (("1" (skosimp)
                        (("1" (replace -1 -3)
                          (("1" (hide -1)
                            (("1" (expand n)
                              (("1"
                                (skosimp)
                                (("1"
                                  (skosimp)
                                  (("1"
                                    (typepred "i!1")
                                    (("1"
                                      (replaces -3)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (case
                                           " i!1 = n!1 * b - n!2 * b")
                                          (("1"
                                            (lemma "distributive")
                                            (("1"
                                              (inst
                                               -1
                                               "b"
                                               "n!1"
                                               "-n!2")
                                              (("1"
                                                (replace -1 -2 rl)
                                                (("1"
                                                  (hide -1 -5)
                                                  (("1"
                                                    (lemma
                                                     "trichotomy")
                                                    (("1"
                                                      (inst
                                                       -1
                                                       "n!1 - n!2")
                                                      (("1"
                                                        (prop)
                                                        (("1"
                                                          (case-replace
                                                           "n!1-n!2 = 1")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (case
                                                             "b * (n!1 + -n!2) > b")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil)
                                                             ("2"
                                                              (lemma
                                                               "lt_times_lt_pos1")
                                                              (("2"
                                                                (inst
                                                                 -1
                                                                 "1"
                                                                 "b"
                                                                 "n!1-n!2"
                                                                 "b")
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (replace
                                                           -1
                                                           -2)
                                                          (("2"
                                                            (hide
                                                             -1
                                                             -4)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (lemma
                                                           "neg_times_lt")
                                                          (("3"
                                                            (inst
                                                             -1
                                                             "b"
                                                             "n!1-n!2")
                                                            (("3"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "complement")
            (("2" (expand "member")
              (("2" (expand "Union")
                (("2" (expand "N")
                  (("2" (lemma "euclid_int")
                    (("2" (inst -1 "b" "x!1 - a")
                      (("2" (skeep)
                        (("2" (case-replace "r = 0")
                          (("1" (assert)
                            (("1" (inst 2 "q")
                              (("1"
                                (hide -1 1)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "r")
                            (("2" (hide 3)
                              (("2"
                                (inst 2 "N(a+r)(b)")
                                (("1"
                                  (expand "N")
                                  (("1"
                                    (case "x!1 = q*b + r + a")
                                    (("1"
                                      (hide -3)
                                      (("1"
                                        (inst 2 "q")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 2 3 -1)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand "Ni")
                                  (("2"
                                    (inst 1 "r")
                                    (("1"
                                      (hide -1 -2)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2"
                                      (hide -2)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (Ni const-decl "setofsets[int]" inf_prime_topology nil)
    (Union const-decl "set" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (complement const-decl "set" sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (TRUE const-decl "bool" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (neg_times_lt formula-decl nil real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (trichotomy formula-decl nil real_axioms nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (distributive formula-decl nil number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (euclid_int formula-decl nil euclidean_division nil))
   SHOSTAK))
 (IMP_topology_TCC1 0
  (IMP_topology_TCC1-1 nil 3894301133
   ("" (lemma "N_Z_topology") (("" (propax) nil nil)) nil)
   ((N_Z_topology formula-decl nil inf_prime_topology nil)) nil
   (IMP_topology subtype
    "extend[setof[int], (inf_prime_topology.open_N_Z?), booleans.bool, booleans.FALSE].extend(sets[(inf_prime_topology.open_N_Z?)].fullset)"
    "topology[int]")))
 (open_is_infinite 0
  (open_is_infinite-1 nil 3894301559
   ("" (skosimp)
    (("" (expand "nonempty?")
      (("" (expand "empty?")
        (("" (skosimp)
          (("" (expand "member")
            (("" (typepred "A!1")
              (("" (expand "open?")
                (("" (expand "member")
                  (("" (expand "extend")
                    (("" (prop)
                      (("" (expand "open_N_Z?")
                        (("" (prop)
                          (("1" (grind) nil nil)
                           ("2" (inst -1 "x!1")
                            (("2" (skosimp)
                              (("2"
                                (lemma "infinite_superset[int]")
                                (("2"
                                  (inst -1 "N(x!1)(b!1)" "A!1")
                                  (("1" (prop) nil nil)
                                   ("2"
                                    (hide -2 -3 -4 -5)
                                    (("2"
                                      (lemma "Nab_is_infinite")
                                      (("2"
                                        (inst -1 "x!1" "b!1")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (setof type-eq-decl nil defined_types nil)
    (FALSE const-decl "bool" booleans nil)
    (extend const-decl "R" extend nil)
    (fullset const-decl "set" sets nil)
    (open? const-decl "bool" topology topology)
    (emptyset const-decl "set" sets nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (infinite_set type-eq-decl nil infinite_sets_def nil)
    (Nab_is_infinite formula-decl nil inf_prime_topology nil)
    (infinite_superset formula-decl nil infinite_sets_def nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   SHOSTAK))
 (Nab_open 0
  (Nab_open-1 nil 3894301561
   ("" (assert) (("" (postpone) nil nil)) nil)
   ((open? const-decl "bool" topology topology)
    (extend const-decl "R" extend nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (set type-eq-decl nil sets nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (subset? const-decl "bool" sets nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   SHOSTAK))
 (Nab_closed 0
  (Nab_closed-1 nil 3894301562
   ("" (skeep)
    (("" (expand "closed?")
      (("" (expand "member")
        (("" (expand "extend")
          (("" (prop)
            (("1" (expand "fullset") (("1" (propax) nil nil)) nil)
             ("2" (lemma "Nab_charac")
              (("2" (inst -1 "a" "b")
                (("2" (lemma "complement_complement[int]")
                  (("2" (inst -1 "Union(Ni(a)(b))")
                    (("2" (replace -2 -1 rl)
                      (("2" (lemma "any_union_open_is_open")
                        (("2" (inst -1 "Ni(a)(b)")
                          (("2" (assert)
                            (("2" (hide - 2)
                              (("2"
                                (skeep)
                                (("2"
                                  (typepred "o")
                                  (("2"
                                    (expand "Ni")
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (lemma "Nab_open")
                                        (("2"
                                          (inst -1 "i+a" "b")
                                          (("2"
                                            (replace -2 -1 rl)
                                            (("2"
                                              (hide -2)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((closed? const-decl "bool" topology topology)
    (extend const-decl "R" extend nil)
    (Nab_charac formula-decl nil inf_prime_topology nil)
    (complement_complement formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (subset? const-decl "bool" sets nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (FALSE const-decl "bool" booleans nil)
    (open? const-decl "bool" topology topology)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (Nab_open formula-decl nil inf_prime_topology nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (any_union_open_is_open formula-decl nil inf_prime_topology nil)
    (Ni const-decl "setofsets[int]" inf_prime_topology nil)
    (Union const-decl "set" sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil))
   SHOSTAK))
 (N_prime_TCC1 0
  (N_prime_TCC1-1 nil 3894301133 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (prime? const-decl "bool" primes ints)
    (> const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (/= const-decl "boolean" notequal nil))
   nil (N_prime subtype "inf_prime_topology.p" "posint")))
 (one_prime_decomposition_ind 0
  (one_prime_decomposition_ind-1 nil 3894306356
   ("" (assert) (("" (postpone) nil nil)) nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (prime_2 formula-decl nil primes ints)
    (divides_zero formula-decl nil divides nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (TRUE const-decl "bool" booleans nil)
    (divisor_smaller formula-decl nil divides nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (divides_transitive formula-decl nil divides nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (divides_reflexive formula-decl nil divides nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (prime? const-decl "bool" primes ints)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   SHOSTAK))
 (one_prime_decomposition 0
  (one_prime_decomposition-1 nil 3894301563
   ("" (skeep)
    (("" (rewrite "one_prime_decomposition_ind")
      (("1" (grind) nil nil)
       ("2" (lemma "one_prime_decomposition_ind")
        (("2" (inst -1 "-x")
          (("2" (prop)
            (("1" (skeep)
              (("1" (inst 3 "p")
                (("1" (expand "divides")
                  (("1" (skeep)
                    (("1" (inst 3 "-x_1") (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (one_prime_decomposition_ind formula-decl nil inf_prime_topology
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (/= const-decl "boolean" notequal nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (prime? const-decl "bool" primes ints))
   SHOSTAK))
 (Union_Nprime 0
  (Union_Nprime-1 nil 3894301564
   ("" (decompose-equality)
    (("" (iff)
      (("" (prop)
        (("1" (expand "Union")
          (("1" (expand "complement")
            (("1" (expand "member")
              (("1" (prop)
                (("1" (lemma "one_prime_decomposition")
                  (("1" (inst -1 "x!1")
                    (("1" (prop)
                      (("1" (skeep)
                        (("1" (expand "divides")
                          (("1" (skeep)
                            (("1" (inst 3 "N(0)(p)")
                              (("1"
                                (expand "N")
                                (("1"
                                  (inst 3 "x")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "N_prime")
                                (("2" (inst 1 "p") nil nil))
                                nil)
                               ("3"
                                (typepred "p")
                                (("3"
                                  (expand "prime?")
                                  (("3"
                                    (flatten)
                                    (("3" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide 3) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "Union")
          (("2" (skosimp)
            (("2" (typepred "a!1")
              (("2" (expand "N_prime")
                (("2" (skosimp)
                  (("2" (replace -1 -2)
                    (("2" (hide -1)
                      (("2" (expand "N")
                        (("2" (skosimp)
                          (("2" (typepred "p!1")
                            (("2" (expand "complement")
                              (("2"
                                (expand "member")
                                (("2"
                                  (prop)
                                  (("1"
                                    (expand "prime?")
                                    (("1"
                                      (replace -1 -3)
                                      (("1"
                                        (lemma "product_one")
                                        (("1"
                                          (inst -1 "n!1" "p!1")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (prop)
                                              (("1"
                                                (hide -1 -3 -4 -6)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide -1 -3 -4 -6)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "prime?")
                                    (("2"
                                      (prop)
                                      (("2"
                                        (hide -2)
                                        (("2"
                                          (replace -1 -3)
                                          (("2"
                                            (hide -1)
                                            (("2"
                                              (case "1 = -n!1*p!1")
                                              (("1"
                                                (hide -3)
                                                (("1"
                                                  (lemma "product_one")
                                                  (("1"
                                                    (inst
                                                     -1
                                                     "-n!1"
                                                     "p!1")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide -1)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((product_one formula-decl nil divides nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (member const-decl "bool" sets nil)
    (one_prime_decomposition formula-decl nil inf_prime_topology nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (> const-decl "bool" reals nil)
    (prime? const-decl "bool" primes ints)
    (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (complement const-decl "set" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (Union const-decl "set" sets nil)
    (N_prime const-decl "setofsets[int]" inf_prime_topology nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   SHOSTAK))
 (set_one_mone_is_finite 0
  (set_one_mone_is_finite-1 nil 3894301565
   ("" (expand "is_finite")
    ((""
      (inst 1 "2"
       "LAMBDA (i:({x: int | x = 1 OR x = -1})): (IF i = 1 THEN 0 ELSE 1 ENDIF)")
      (("" (expand "injective?") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint8 type-eq-decl nil integertypes nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil))
   SHOSTAK))
 (prime_Nprime_bij 0
  (prime_Nprime_bij-1 nil 3894301567
   ("" (inst 1 "LAMBDA(p: (fullset[(prime?)])): N(0)(p)")
    (("1" (expand "bijective?")
      (("1" (prop)
        (("1" (expand "injective?")
          (("1" (skeep)
            (("1" (decompose-equality -1)
              (("1" (inst -1 "x1")
                (("1" (iff)
                  (("1" (prop)
                    (("1" (hide -1)
                      (("1" (expand "N")
                        (("1" (skeep)
                          (("1" (typepred "x1" "x2")
                            (("1" (hide -2 -4)
                              (("1"
                                (expand "prime?")
                                (("1"
                                  (prop)
                                  (("1"
                                    (inst -1 "x2")
                                    (("1"
                                      (prop)
                                      (("1"
                                        (expand "divides")
                                        (("1"
                                          (inst 1 "n")
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil)
                                       ("3" (assert) nil nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide (1 3))
                      (("2" (expand "N")
                        (("2" (inst 1 "1") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide (-1 2))
                (("2" (typepred "x2")
                  (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil))
                nil)
               ("3" (hide (-1 2))
                (("3" (typepred "x1")
                  (("3" (hide -2) (("3" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "surjective?")
          (("2" (skeep)
            (("2" (typepred "y")
              (("2" (expand "N_prime")
                (("2" (skeep)
                  (("2" (inst 1 "p")
                    (("1" (assert) nil nil)
                     ("2" (hide -1) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (setof type-eq-decl nil defined_types nil)
    (setofsets type-eq-decl nil sets nil)
    (N_prime const-decl "setofsets[int]" inf_prime_topology nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (N const-decl "set[int]" inf_prime_topology nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (prime? const-decl "bool" primes ints)
    (set type-eq-decl nil sets nil) (fullset const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil) (> const-decl "bool" reals nil))
   SHOSTAK))
 (fin_prime_closed_Np 0
  (fin_prime_closed_Np-1 nil 3894301568
   ("" (prop)
    (("" (lemma "closed_Union")
      (("" (inst -1 "N_prime")
        (("" (prop)
          (("1" (expand "is_finite")
            (("1" (skosimp)
              (("1" (lemma "prime_Nprime_bij")
                (("1" (skeep)
                  (("1" (inst 1 "N!1" "f!1 o inverse(f)")
                    (("1" (expand "bijective?")
                      (("1" (prop)
                        (("1"
                          (lemma
                           "composition_injective[(N_prime), (fullset[(prime?)]), below[N!1]]")
                          (("1" (inst -1 "inverse(f)" "f!1")
                            (("1"
                              (lemma
                               "bij_inv_is_bij_alt[(fullset[(prime?)]), (N_prime)]")
                              (("1"
                                (inst -1 "f" "inverse(f)")
                                (("1"
                                  (expand "bijective?")
                                  (("1" (prop) nil nil))
                                  nil)
                                 ("2"
                                  (hide (-3 2 3 4))
                                  (("2"
                                    (lemma
                                     "left_inverse_is_inverse[(fullset[(prime?)]), (N_prime)]")
                                    (("2"
                                      (inst -1 "f" "inverse(f)")
                                      (("1"
                                        (hide 2)
                                        (("1"
                                          (lemma
                                           "inj_left[(fullset[(prime?)]), (N_prime)]")
                                          (("1"
                                            (inst -1 "f")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (hide-all-but 1)
                                            (("2"
                                              (inst 1 "2")
                                              (("2"
                                                (expand "fullset")
                                                (("2"
                                                  (rewrite "prime_2")
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but 1)
                                        (("2"
                                          (inst 1 "2")
                                          (("2"
                                            (expand "fullset")
                                            (("2"
                                              (rewrite "prime_2")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (inst 1 "2")
                                  (("3"
                                    (hide-all-but 1)
                                    (("3"
                                      (expand "fullset")
                                      (("3"
                                        (rewrite "prime_2")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("4"
                                  (hide-all-but (-1 -2 1))
                                  (("4"
                                    (expand "bijective?")
                                    (("4" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst 1 "2")
                              (("2"
                                (expand "fullset")
                                (("2" (rewrite "prime_2") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst 1 "2")
                      (("2" (expand "fullset")
                        (("2" (rewrite "prime_2") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "every")
            (("2" (skeep)
              (("2" (typepred "x")
                (("2" (expand "N_prime")
                  (("2" (skeep)
                    (("2" (lemma "Nab_closed")
                      (("2" (inst -1 "0" "p")
                        (("1" (assert) nil nil)
                         ("2" (typepred "p")
                          (("2" (expand "prime?")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fullset const-decl "set" sets nil)
    (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (closed_Union formula-decl nil topology topology)
    (bijective? const-decl "bool" functions nil)
    (composition_injective judgement-tcc nil function_props nil)
    (bij_inv_is_bij_alt formula-decl nil function_inverse_def nil)
    (left_inverse? const-decl "bool" function_inverse_def nil)
    (inj_left formula-decl nil function_inverse nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (prime_2 formula-decl nil primes ints)
    (left_inverse_is_inverse formula-decl nil function_inverse_def nil)
    (inverse? const-decl "bool" function_inverse_def nil)
    (injective? const-decl "bool" functions nil)
    (inverse const-decl "D" function_inverse nil)
    (O const-decl "T3" function_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (prime? const-decl "bool" primes ints)
    (TRUE const-decl "bool" booleans nil)
    (prime_Nprime_bij formula-decl nil inf_prime_topology nil)
    (is_finite const-decl "bool" finite_sets nil)
    (Nab_closed formula-decl nil inf_prime_topology nil)
    (Union_surjective name-judgement
     "(surjective?[setofsets[T], set[T]])" sets_lemmas nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (setofsets type-eq-decl nil sets nil)
    (N_prime const-decl "setofsets[int]" inf_prime_topology nil))
   SHOSTAK))
 (prime_set_is_infinite 0
  (prime_set_is_infinite-1 nil 3894301569
   ("" (assert) (("" (postpone) nil nil)) nil)
   ((Union_Nprime formula-decl nil inf_prime_topology nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (open_is_infinite formula-decl nil inf_prime_topology nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (open? const-decl "bool" topology topology)
    (set_one_mone_is_finite formula-decl nil inf_prime_topology nil)
    (fullset const-decl "set" sets nil)
    (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (open_N_Z? const-decl "bool" inf_prime_topology nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (closed_complement formula-decl nil topology topology)
    (fin_prime_closed_Np formula-decl nil inf_prime_topology nil))
   SHOSTAK)))

